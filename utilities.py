import math
import json
import numpy as np
from scipy import stats as st
from scipy.interpolate import interp1d
from scipy.optimize import curve_fit
from scipy.ndimage import gaussian_filter1d
from datetime import timedelta


output_filename='exported_data'

class mouse_data:
     """class to store data we want to keep"""
     def __init__(self,mouse_id,F490,F405,fs,t_start=None,n=None,t=np.array([]),t_stim=None, cond = 0):
         self.mouse_id=mouse_id
         self.F490=F490
         self.F405=F405
         self.fs=fs
         self.n=n if n else len(F490)
         self.t=t if t.any() else np.arange(0,(self.n)/fs,1/fs)
         if t_start: self.t_start=t_start
         if t_stim: self.t_stim=t_stim
         self.cond = cond

class NoStimTime(Exception):
    """
    no stimulus time has been specified for this mouse
    """
    pass

class Encoder(json.JSONEncoder):
    """json encoder for all json files generated/used in the pipeline"""
    def default(self, obj):
        if isinstance(obj, np.ndarray):
            return {'ndarray': obj.tolist()}
        if isinstance(obj,Callable):
            return {'function':obj.__name__}
        if isinstance(obj,mouse_data):
            return {'mouse_data':obj.__dict__}
        return json.JSONEncoder.default(self, obj)

def hook(obj):
    """hook for loading data from json files generated by this pipeline"""
    if 'ndarray' in obj:
        return np.array(obj['ndarray'])
    if 'mouse_data' in obj:
        return mouse_data(**obj['mouse_data'])
    return obj

def resample(x,y, fs_n=1, kind='linear'):
    """resample data by interpolation"""
    #adapted from: https://stackoverflow.com/questions/29085268/resample-a-numpy-array/52347385
    f = interp1d(x,y, kind)
    x2=np.arange(round(x[0]), round(x[-1])+1/fs_n,1/fs_n)
    return x2,f(x2)

def select_data(data:mouse_data,t_endrec,t_prestim):
    """
    select the data that will be used in the analysis'
    
    Parameters
    ----------
    data: mouse_data
        raw data to select from
    t_endrec: float
        the amount of time in seconds from stim to the end of the recording 
        to keep
    Returns
    -------
    pre_stim_490: numpy.ndarray
        490 data pre stim
    pre_stim_405: numpy.ndarray
        405 data pre stim
    sel_490: numpy.ndarray
        cropped 490 data
    sel_405: numpy.ndarray
        cropped 405 data
    t: np.ndarray
        updated time array for the normalized data
    """

    start_ind=get_sample(data.t_stim-t_prestim,data.fs)
    stim_ind=get_sample(data.t_stim,data.fs)
    end_ind=get_sample(data.t_stim+t_endrec,data.fs)

    pre_stim_490=data.F490[start_ind-1:stim_ind+1]
    pre_stim_405=data.F405[start_ind-1:stim_ind+1]
    sel_490=data.F490[start_ind-1:end_ind+2]
    sel_405=data.F405[start_ind-1:end_ind+2]

    t=data.t[start_ind-1:end_ind+2]-data.t[stim_ind]

    return pre_stim_490, pre_stim_405, sel_490, sel_405, t

def get_sample(t,fs):
    """
    get sample just after desired time
    """
    return math.floor(t*fs)+1

def norm_to_median_pre_stim(data:mouse_data,t_endrec,t_prestim):
    """
    normalize to the median of the data 5 minutes before the stimulus

    Parameters
    ---------
    rec: mouse_data
        an instance of a mouse_data object storing the raw data for a
        given mouse
    t_endrec: float
        the amount of time in seconds from stim to the end of the recording 
        to keep in the analysis

    Returns
    -------
    normed_490: numpy.ndarray
        1D array of normalized 490 data 
    normed_405: numpy.ndarray
        1D array of normalized 405 data 
    t: np.ndarray
        updated time array for the normalized data
    """

    pre_stim_490, pre_stim_405, sel_490, sel_405,t=select_data(data,t_endrec,t_prestim)

    #compute the baseline by taking the median of the 5 miutes pre-stimu data
    f490_baseline=np.median(pre_stim_490)
    f405_baseline=np.median(pre_stim_405)

    #normalize the 490 and 405 to the respctive baseline
    normed_490=(sel_490-f490_baseline)/f490_baseline
    normed_405=(sel_405-f405_baseline)/f405_baseline
    return normed_490, normed_405, t



def norm_to_405(data:mouse_data,t_endrec,t_prestim):
    """
    normalize to a linear fit of the 405 data'

    Parameters
    ---------
    rec: mouse_data
        an instance of a mouse_data object storing the raw data for a
        given mouse
    t_endrec: float
        the amount of time in seconds from stim to the end of the recording 
        to keep in the analysis

    Returns
    -------
    normed_490: numpy.ndarray
        1D array of normalized 490 data 
    normed_405: numpy.ndarray
        1D array of normalized 405 data 
    t: np.ndarray
        updated time array for the normalized data
    """
    _, _, sel_490, sel_405,t = select_data(data,t_endrec,t_prestim)

    #downsample temporarily for efficiency and roughly low pass filter for a cleaner fit
    filt_ds490 = gaussian_filter1d(sel_490[::int(data.fs)],sigma = 10)
    filt_ds405 = gaussian_filter1d(sel_405[::int(data.fs)],sigma = 10)

    #fit the 405 data to the 490
    m, b = np.polyfit(filt_ds405, filt_ds490, 1)
    f0_ds = m * filt_ds405 + b

    # upsample the baseline estimate
    f0_fn = interp1d( t[::int(data.fs)], f0_ds, bounds_error = False, fill_value = 'extrapolate')
    f0 = f0_fn(t)

    normed_490 = (sel_490 - f0)/f0
    normed_405 = (sel_405 * m + b - f0)/f0

    return normed_490, normed_405, t

def norm_to_405_sub_base(data:mouse_data,t_endrec,t_prestim):
    normed_490, normed_405, t = norm_to_405(data,t_endrec,t_prestim)
    normed_490 -= np.median(normed_490[:get_sample(t_prestim, data.fs)])
    normed_405 -= np.median(normed_405[:get_sample(t_prestim, data.fs)])
    return normed_490, normed_405, t

def zscore(data:mouse_data,t_endrec,t_prestim, detrend_method = norm_to_405,  s = .3):
    normed_490, normed_405, t = detrend_method(data, t_endrec, t_prestim)
    normed_490 = (normed_490 - normed_490.mean())/normed_490.std()
    normed_405 = s * (normed_405 - normed_405.mean())/normed_405.std()
    return normed_490, normed_405, t

def delta_zscore(data:mouse_data,t_endrec,t_prestim, detrend_method = norm_to_405, s=.3):
    normed_490, normed_405, t = zscore(data, t_endrec, t_prestim, detrend_method, s)
    normed_490 = normed_490 - np.median(normed_490[:t_prestim])
    return normed_490, normed_405, t